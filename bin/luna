#!/usr/bin/env python
'''
Written by Dmitry Chirikov <dmitry@chirikov.ru>
This file is part of Luna, cluster provisioning tool
https://github.com/dchirikov/luna

This file is part of Luna.

Luna is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Luna is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Luna.  If not, see <http://www.gnu.org/licenses/>.

'''

import os
import sys
import luna
import tempfile
import subprocess
import logging
import hostlist
import time
import traceback

from signal import signal, SIGPIPE, SIG_DFL, SIGHUP
from argparse import ArgumentParser

from luna import utils


# Restore SIGPIPE's default unix behaviour
# (newbebweb.blogspot.nl/2012/02/python-head-ioerror-errno-32-broken.html)
# (docs.python.org/library/signal.html)

signal(SIGPIPE, SIG_DFL)

logging.basicConfig(level=logging.INFO)
log = logging.getLogger()
def_format = '%20s%40s\n'


def print_table(header, content):
    for key in content:
        if key[1] is None:
            key[1] = '-'

    out = {'header': header, 'content': content}
    (lengths, header_array, content_array) = utils.helpers.format_output(out)

    spaces = 4
    fmt_str = [
        "| %-" + str(spaces + lengths[i]) + "s" for i in range(len(lengths))
    ]

    #out_len = sum(lengths) + (spaces + 2) * len(lengths) + 1
    format_string = "".join(fmt_str)+"|"

    separator = "+" + "+".join(["-" * (i + spaces + 1) for i in lengths]) + "+"

    print(separator)

    for i in range(len(header_array)):
        print(format_string % tuple(header_array[i]))

    print(separator)

    for i in range(len(content_array)):
        print(format_string % tuple(content_array[i]))

    print(separator)


def _edit_script(old_script):
    # old_script can be None
    if not bool(old_script):
        old_script = ''
    script = ''
    if not sys.stdin.isatty():
        for line in sys.stdin:
            script += line
    else:
        EDITOR = os.environ.get('EDITOR', 'vi')
        tmpfile = tempfile.NamedTemporaryFile(suffix=".tmp")
        tmpfile.write(old_script)
        tmpfile.flush()
        subprocess.call([EDITOR, tmpfile.name])
        tmpfile.file.seek(0)
        for line in tmpfile.file:
            script += line
    return script.rstrip('\n')


def check_active_node():
    if not luna.Cluster().is_active():
        log.error("Inactive HA node.")
        exit(1)

#################### Cluster


def cluster_init(**args):
    cluster = luna.Cluster(
        create=True,
        nodeprefix=args['nodeprefix'],
        nodedigits=args['nodedigits'],
        path=args['path'],
        user=args['user']
    )

    if not cluster:
        log.error('Error creating cluster.')
        return False

    ret = cluster.set(
        'frontend_address',
        args['frontend_address']
    )

    return ret


def cluster_delete(**args):
    cluster = luna.Cluster()
    return cluster.delete(args['force'])


def cluster_change(**args):
    cluster = luna.Cluster()

    if args['comment']:
        old_comment = cluster.get('comment')
        cluster.set('comment', _edit_script(old_comment))
        return True

    for key in args:
        if args[key] == None or args[key] == False:
            continue
        res = cluster.set(key, args[key])
        if not bool(res):
            log.error('Error changing {}'.format(key))
            return False

    return True


def cluster_show(**args):
    cluster = luna.luna.Cluster()
    if args['raw']:
        print(cluster.nice_json)
        return True
    if args['comment']:
        print(cluster.get('comment'))
        return True
    out_json = cluster.show()
    out_str = []
    out_json.pop('name')
    out_json.pop('db_version')
    comment = out_json.pop('comment')
    if bool(cluster.get('dhcp_net')):
        out_json.pop('dhcp_net')
        out_json.pop('dhcp_range_start')
        out_json.pop('dhcp_range_end')
        out_json['dhcp_net'] = '[' + cluster.get('dhcp_net') + ']'
        out_json['dhcp_range_start'] = cluster.get('dhcp_range_start')
        out_json['dhcp_range_end'] = cluster.get('dhcp_range_end')
    for key in sorted(out_json):
        out_str.append([key, out_json[key]])
    out_str.append(['comment', comment])
    print_table(['Parameter', 'Value'], out_str)
    return True


def cluster_sync(**args):
    cluster = luna.Cluster()
    if not cluster.is_ha():
        log.error('Cluster is not in HA mode.')
        return True
    path = cluster.get("path")
    ips = cluster.get_cluster_ips()
    for ip in ips[1:]:
        print("%s:%s => %s:%s" % (ips[0], path, ip, path))
        utils.helpers.rsync_data(ip, path)
    print("Done. Luna daemons probably need to be restarted manually.")


def cluster_makedns(**args):
    cluster = luna.Cluster()
    res = cluster.makedns()
    if not res:
        return False
    log.info("Reloading local named.")
    proc = subprocess.Popen(
        ['/usr/bin/systemctl', 'reload', "named"],
        stdout=subprocess.PIPE,
        close_fds=True
    )
    proc.communicate()[0]
    if proc.returncode:
        log.error(
            "Unable to reload named. Exit code is non-zero: {}."
            .format(proc.returncode)
        )
        return False
    log.info("Success.")
    if not cluster.is_ha():
        return True
    files = []
    includefile = cluster.get('named_include_file')
    zonedir = cluster.get('named_zone_dir')
    files.extend([includefile])
    files.extend([zonedir])
    ips = cluster.get_cluster_ips()
    for ip in ips[1:]:
        for path in files:
            log.info("%s:%s => %s:%s" % (ips[0], path, ip, path))
            utils.helpers.rsync_data(ip, path)
        log.info("Reloading remote namded on " + ip + ".")
        ssh_proc = subprocess.Popen(
            ['/usr/bin/ssh',
             '-o', 'StrictHostKeyChecking=no',
             '-o', 'UserKnownHostsFile=/dev/null', ip,
             'systemctl', "reload", "named"],
            stdout=subprocess.PIPE,
            close_fds=True
        )
        ssh_proc.communicate()[0]
        if ssh_proc.returncode:
            log.info(
                "Unable to reload named on " +
                ip + ". Exit code is non-zero."
            )
            return False
        log.info("Success.")
    return True


def cluster_makedhcp(**args):
    cluster = luna.Cluster()
    no_ha = not args['native_dhcp_ha']

    if args['network'] and not (args['start_ip'] and args['end_ip']):
        log.error('Network range should be specified')
        return False

    if (args['start_ip'] or args['end_ip']) and not args['network']:
        log.error('Network should be specified')
        return False

    res = cluster.makedhcp(args['network'], args['start_ip'],
                           args['end_ip'], no_ha=no_ha)
    if not res:
        log.error('Error on creating DHCP config.')
        return False

    _run_command(
        ['/usr/bin/systemctl', 'stop', "dhcpd"],
        "Stopping local dhcpd.",
        "Unable to stop named. Exit code is non-zero."
    )
    if cluster.is_ha():
        ips = cluster.get_cluster_ips()
        for ip in ips:
            _run_command(
                ['/usr/bin/ssh',
                 '-o', 'StrictHostKeyChecking=no',
                 '-o', 'UserKnownHostsFile=/dev/null', ip,
                 'systemctl', "stop", "dhcpd"],
                "Stop dhcpd on " + ip + ".",
                "Unable to stop dhcpd."
            )
            _run_command(
                ['/usr/bin/scp',
                 '-o', 'StrictHostKeyChecking=no',
                 '-o', 'UserKnownHostsFile=/dev/null',
                 '/etc/dhcp/dhcpd-secondary.conf',
                 ip + ":/etc/dhcp/dhcpd.conf"],
                "Copy dhcpd config file to " + ip + ".",
                "Unable to copy file."
            )
            _run_command(
                ['/usr/bin/ssh',
                 '-o', 'StrictHostKeyChecking=no',
                 '-o', 'UserKnownHostsFile=/dev/null', ip,
                 'systemctl', "stop", "dhcpd"],
                "Stop dhcpd on " + ip + ".",
                "Unable to stop dhcpd."
            )
            _run_command(
                ['/usr/bin/ssh',
                 '-o', 'StrictHostKeyChecking=no',
                 '-o', 'UserKnownHostsFile=/dev/null', ip,
                 'rm', "-rf", "/var/lib/dhcpd/dhcpd.*"],
                "Removing lease files on " + ip + ".",
                "Unable to remove."
            )
            _run_command(
                ['/usr/bin/ssh',
                 '-o', 'StrictHostKeyChecking=no',
                 '-o', 'UserKnownHostsFile=/dev/null', ip,
                 'touch', "/var/lib/dhcpd/dhcpd.leases"],
                "Create lease file on " + ip + ".",
                "Unable to create."
            )
    log.info("Remove lease files")
    try:
        f = open('/var/lib/dhcpd/dhcpd.leases', 'w')
        f.close()
    except:
        log.warning('Error on erasing dhcpd.leases. Trying to proceed.')
    try:
        os.remove('/var/lib/dhcpd/dhcpd.leases~')
    except:
        log.warning('Erron on removing dhcpd.leases~. Trying to proceed.')
    _run_command(
        ['/usr/bin/systemctl', 'start', "dhcpd"],
        "Starting local dhcpd.",
        "Unable to start dhcpd. Exit code is non-zero."
    )
    time.sleep(3)
    if not cluster.is_ha() or no_ha:
        return True
    for ip in ips:
        _run_command(
            ['/usr/bin/ssh',
             '-o', 'StrictHostKeyChecking=no',
             '-o', 'UserKnownHostsFile=/dev/null', ip,
             'systemctl', "start", "dhcpd"],
            "Start dhcpd on " + ip + ".",
            "Unable to start dhcpd."
        )
    return True


def cluster_listmacs(**args):
    cluster = luna.Cluster()
    cached_macs = cluster.list_cached_macs()
    out_str = []
    for elem in cached_macs:
        if elem['configured']:
            conf = 'yes'
        else:
            conf = 'no'
        out_str.append(
            [
                elem['switch'],
                elem['port'],
                elem['portname'],
                elem['mac'],
                conf,
                elem['node'] or '-'
            ]
        )

    print_table(
        ['Switch', 'Port', 'Portname', 'MAC', 'Confport', 'Node'], out_str)

    return True


def _run_command(cmd, descr, err):
    log.info(descr)
    ssh_proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, close_fds=True)
    ssh_proc.communicate()[0]
    if ssh_proc.returncode:
        log.error(err)
        sys.exit(1)

#################### OsImage


def osimage_list():
    lst = luna.list('osimage')
    header = ['Name', 'Path', 'Kernel version']
    content = []
    for elem in lst:
        osimage = luna.OsImage(elem)
        if not bool(osimage):
            log.error('Unable to get OsImage {}'.format(elem))
            return False
        content.append([elem, osimage.get('path'), osimage.get('kernver')])
    print_table(header, content)
    return True


def osimage_show(**args):
    osimage = luna.OsImage(name=args['name'])
    if args['raw']:
        print(osimage.nice_json)
        return True
    if args['path']:
        print(osimage.get('path'))
        return True
    if args['grab_filesystems']:
        print(osimage.get('grab_filesystems'))
        return True
    if args['comment']:
        print(osimage.get('comment'))
        return True
    if args['kernver']:
        for elem in osimage.list_kernels():
            if elem == osimage.get('kernver'):
                print(elem + ' <=')
                continue
            print(elem)
        return True
    if args['grab_exclude_list']:
        print(osimage.get('grab_exclude_list'))
        return True
    out_json = osimage.show()
    #out_str = ''
    header = ['Parameter', 'Value']
    content = []
    name = out_json.pop('name')
    comment = out_json.pop('comment')
    content.append(['name', name])
    for key in sorted(out_json):
        content.append([key, out_json[key]])
    content.append(['comment', comment])
    print_table(header, content)
    return True


def osimage_listkerns(**args):
    osimage = luna.OsImage(name=args['name'])
    for elem in osimage.list_kernels():
        print(elem)
    return True


def osimage_add(**args):
    args['create'] = True
    osimage = luna.OsImage(**args)
    if not bool(osimage):
        log.error("Error creating osimage")
        return False
    return True


def osimage_delete(**args):
    osimage = luna.OsImage(args['name'])
    return osimage.delete()


def osimage_change(**args):
    osimage = luna.OsImage(args['name'])
    args.pop('name')

    if args['grab_exclude_list']:
        old_list = osimage.get('grab_exclude_list')
        new_list = _edit_script(old_list)
        osimage.set('grab_exclude_list', new_list)
        return True

    if args['comment']:
        old_comment = osimage.get('comment')
        osimage.set('comment', _edit_script(old_comment))
        return True

    ret = True
    for key in args:
        if not args[key]:
            continue
        ret = osimage.set(key, args[key])
        if not (ret):
            log.error("Error changing '{}'".format(key))

    return True


def osimage_pack(**args):
    def pack_image(osimage):

        res = True

        try:
            log.info('Creating tarball.')
            res = osimage.create_tarball()
        except:
            res = False

        if not res:
            log.error("Error on creating tarball")
            return False

        log.info('Done.')

        res = True

        try:
            log.info('Creating torrent.')
            res = osimage.create_torrent()
        except:
            res = False

        if not res:
            log.error("Error on creating torrent.")
            return False

        log.info('Done.')
        return True

    def pack_boot(osimage, copy):
        if not copy:
            log.info('Copying kernel & packing inirtd.')
            res = osimage.pack_boot()
        else:
            log.info('Copying kernel and initrd from image.')
            res = osimage.copy_boot()

        if not res:
            log.error('Error occured')
            return False

        log.info('Done.')
        return True

    def update_ltorrent():
        try:
            pf = open(luna.Cluster().get('torrent_pidfile'), 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None
        if pid:
            try:
                os.kill(pid, SIGHUP)
            except OSError:
                log.error(("No such process with pid %i. " +
                           "Is ltorrent running?") % pid)
                return False
        else:
            log.error("Ltorrent is not running")
            return False
        return True

    osimage = luna.OsImage(args['name'])

    if args['boot']:
        pack_boot(osimage, args['copy_boot'])
        return update_ltorrent()

    if args['image']:
        return pack_image(osimage)

    if not pack_image(osimage):
        return False

    if not pack_boot(osimage, args['copy_boot']):
        return False

    if not update_ltorrent():
        return False

    return osimage_sync(name=args['name'])


def osimage_grab(**args):
    osimage = luna.OsImage(args['name'])
    res = osimage.grab_host(
        host=args['host'],
        dry_run=args['dry_run'],
        verbose=args['verbose']
    )
    return res


def osimage_sync(**args):
    name = args['name']
    cluster = luna.Cluster()
    if not cluster.is_ha():
        return True
    lunapath = cluster.get("path")
    osimage = luna.OsImage(name)
    osimagepath = osimage.get("path")
    initrdfile = lunapath + "/boot/" + osimage.get("initrdfile")
    kernfile = lunapath + "/boot/" + osimage.get("kernfile")
    tarball = lunapath + "/torrents/" + osimage.get("tarball") + ".tgz"
    torrent = lunapath + "/torrents/" + osimage.get("torrent") + ".torrent"
    ips = cluster.get_cluster_ips()
    for ip in ips[1:]:
        for path in (osimagepath, initrdfile, kernfile, tarball, torrent):
            log.info("%s:%s => %s:%s" % (ips[0], path, ip, path))
            utils.helpers.rsync_data(ip, path)
        log.info("Reloading ltorrent on " + ip)
        ssh_proc = subprocess.Popen(
            [
                '/usr/bin/ssh',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null', ip,
                '/usr/sbin/ltorrent', "reload"
            ],
            stdout=subprocess.PIPE,
            close_fds=True
        )
        ssh_proc.communicate()[0]
        if ssh_proc.returncode:
            log.error("Exit code is non-zero")
            sys.exit(1)
    log.info("Done.")
    return True


def osimage_clone(**args):
    osimage = luna.OsImage(args['name'])
    return osimage.clone(args['to'], args['path'])


def osimage_rename(**args):
    osimage = luna.OsImage(args['name'])
    return osimage.rename(args['newname'])


#################### BMCSetup


def bmcsetup_list(**args):
    lst = luna.list('bmcsetup')
    header = ['Name', 'User', 'Password']
    content = []
    for elem in lst:
        bmcsetup = luna.BMCSetup(elem)
        content.append([elem, bmcsetup.get('user'), bmcsetup.get('password')])
    print_table(header, content)
    return True


def bmcsetup_show(**args):

    bmcsetup = luna.BMCSetup(name=args['name'])
    if args['raw']:
        print(bmcsetup.nice_json)
        return True
    if args['comment']:
        print(bmcsetup.get('comment'))
        return True
    out_json = bmcsetup.show()
    header = ['Parameter', 'Value']
    content = []
    name = out_json.pop('name')
    comment = out_json.pop('comment')
    content.append(['name', name])
    for key in sorted(out_json):
        content.append([key, out_json[key]])
    content.append(['comment', comment])
    print_table(header, content)
    return True


def bmcsetup_add(**args):
    args['create'] = True
    bmcsetup = luna.BMCSetup(**args)
    return bool(bmcsetup)


def bmcsetup_change(**args):
    bmcsetup = luna.BMCSetup(args['name'])
    args.pop('name')

    if args['comment']:
        old_comment = bmcsetup.get('comment')
        bmcsetup.set('comment', _edit_script(old_comment))
        return True

    for key in args:
        if not args[key]:
            continue

        if not bmcsetup.set(key, args[key]):
            return False

    return True


def bmcsetup_delete(**args):
    bmcsetup = luna.BMCSetup(args['name'])
    return bmcsetup.delete()


def bmcsetup_rename(**args):
    bmcsetup = luna.BMCSetup(args['name'])
    return bmcsetup.rename(args['newname'])

#################### Network


def network_list():
    networks = luna.list('network')
    header = ['Name', 'Network']
    content = []
    for elem in networks:
        net = luna.Network(elem)
        content.append(
            [elem, net.get('NETWORK') + "/" + str(net.get('PREFIX'))])
    print_table(header, content)
    return True


def network_show(**args):
    name = args['name']
    raw = args['raw']
    reservedips = args['reservedips']
    net = luna.Network(name=name)
    if raw:
        print(net.nice_json)
        return None
    if args['comment']:
        print(net.get('comment'))
        return True
    if reservedips:
        nonfree = utils.freelist.get_nonfree(net['freelist'])
        ips = [utils.ip.reltoa(net['NETWORK'], elem) for elem in nonfree]
        print("\n".join(["%s" % i for i in ips]))
        return None
    out_json = net.show()
    header = ['Parameter', 'Value']
    content = []
    content.append(['name', name])
    out_json.pop('freelist')
    out_json.pop('name')
    comment = out_json.pop('comment')
    out_json['NETWORK'] = net.get('NETWORK')
    out_json['ns_ip'] = net.get('ns_ip')
    for key in sorted(out_json):
        content.append([key, out_json[key]])
    content.append(['comment', comment])
    print_table(header, content)
    return True


def network_add(**args):
    net = luna.Network(
        name=args['name'],
        create=True,
        NETWORK=args['network'],
        PREFIX=args['prefix'],
        ns_hostname=args['ns_hostname'],
        ns_ip=args['ns_ip'],
    )
    return bool(net)


def network_change(**args):
    parm_sum = 0
    for elem in ['include', 'rev_include', 'comment']:
        parm_sum += int(bool(args[elem]))
    if parm_sum > 1:
        log.error('Only one element can be edited')
        return False
    net = luna.Network(name=args['name'])
    if args['comment']:
        old_comment = net.get('comment')
        return net.set('comment', _edit_script(old_comment))
    if bool(args['network']):
        return net.set('NETWORK', args['network'])
    if bool(args['prefix']):
        return net.set('PREFIX', args['prefix'])
    if bool(args['reserve']):
        return net.reserve_ip(args['reserve'])
    if bool(args['release']):
        return net.release_ip(args['release'])
    if bool(args['ns_hostname']):
        return net.set('ns_hostname', args['ns_hostname'])
    if bool(args['ns_ip']):
        return net.set('ns_ip', args['ns_ip'])

    if parm_sum < 1:
        return True

    scr_type = None
    if bool(args['include']):
        scr_type = 'include'
    elif bool(args['rev_include']):
        scr_type = 'rev_include'

    old_script = net.show()[scr_type]
    script = _edit_script(old_script)

    if not bool(script):
        script = ''

    return net.set(scr_type, script)


def network_delete(**args):
    net = luna.Network(args['name'])
    return net.delete()


def network_rename(**args):
    net = luna.Network(args['name'])
    return net.rename(args['newname'])

#################### Group


def _get_group_interfaces(group):
    """
    Nice formatting for interfaces
    """
    interfaces = ""
    if_names = group.list_ifs().keys()
    if_names.sort()

    # get the longest if name
    if_padding = 0
    for k in if_names:
        if len(k) > if_padding:
            if_padding = len(k)

    for k in if_names:
        if_dict = group.show_if(k)
        if_net_str = ""
        first_interface = True

        for ver in ['4', '6']:
            if not if_dict['network'][ver]['network']:
                continue
            net_name = if_dict['network'][ver]['name']
            net = if_dict['network'][ver]['network']
            net_prefix = if_dict['network'][ver]['prefix']
            if first_interface:
                if_net_str += '[{}]:{}/{}\n'.format(net_name, net, net_prefix)
                first_interface = False
            else:
                tmp = '[{}]:{}/{}'.format(net_name, net, net_prefix)
                if_net_str += '{:>{}}{}'.format(" ", if_padding+3, tmp)

        if not if_net_str:
            if_net_str = '-\n'

        if_name = '[' + k + ']:'
        interfaces += '{:<{}}{}\n'.format(
            if_name, if_padding+3, if_net_str[:-1])

    interfaces = interfaces[:-1]

    return interfaces


def group_list(**args):
    groups = luna.list('group')
    groups.sort()
    header = ['Name', 'Osimage', 'Interfaces']
    content = []
    for elem in groups:
        group = luna.Group(elem)
        interfaces = _get_group_interfaces(group)
        content.append([elem, group.show()['osimage'], interfaces])
    print_table(header, content)
    return True


def group_show(**args):
    group = luna.Group(name=args['name'])
    if args['raw']:
        print(group.nice_json)
        return True

    if bool(args['interface']):
        print(group.show_if(args['interface']))
        return True

    scr_type = ''

    if bool(args['prescript']):
        scr_type = 'prescript'

    elif bool(args['partscript']):
        scr_type = 'partscript'

    elif bool(args['postscript']):
        scr_type = 'postscript'

    elif bool(args['comment']):
        scr_type = 'comment'

    if scr_type:
        print(group.get(scr_type))
        return True

    if bool(args['osimage']):
        print(group.show()['osimage'])
        return True

    if bool(args['bmcsetup']):
        print(group.show()['bmcsetup'])
        return True

    out_json = group.show()

    grpname = out_json.pop('name')
    comment = out_json.pop('comment')
    #if_names = group.list_ifs().keys()
    out_json['interfaces'] = _get_group_interfaces(group)
    header = ['Parameter', 'Value']
    content = []
    content.append(['name', grpname])

    for key in sorted(out_json):
        content.append([key, out_json[key]])

    content.append(['comment', comment])

    print_table(header, content)
    return True


def group_add(**args):

    res = True
    net_name = args.pop('network')
    bmcnet_name = args.pop('bmcnetwork')

    # we don't need it actually, but we will be sure
    # network exists before creating group
    network = luna.Network(net_name)
    if bmcnet_name:
        bmcnetwork = luna.Network(bmcnet_name)

    args['create'] = True

    if bmcnet_name:
        args['interfaces'] = ['BOOTIF', 'BMC']
    else:
        args['interfaces'] = ['BOOTIF']

    args['domain'] = network.name

    group = luna.Group(**args)
    res &= group.set_net_to_if('BOOTIF', network.name)

    if bmcnet_name:
        res &= group.set_net_to_if('BMC', bmcnetwork.name)

    return res


def group_change(**args):
    parm_sum = 0
    for elem in ['prescript', 'postscript',
                 'partscript', 'interface', 'comment']:
        parm_sum += int(bool(args[elem]))
    if parm_sum > 1:
        log.error('Only one element can be edited')
        return None
    group = luna.Group(args['name'])
    for txt_field in ['prescript', 'postscript',
                      'partscript', 'comment']:
        if args[txt_field]:
            old_txt_value = group.get(txt_field)
            return group.set(txt_field, _edit_script(old_txt_value))

    if bool(args['interface']):
        if bool(args['add']):
            return group.add_interface(args['interface'])
        elif bool(args['delete']):
            return group.del_interface(args['interface'])
        elif bool(args['setnet']):
            return group.set_net_to_if(args['interface'], args['setnet'])
        elif bool(args['delnet']):
            netname = None
            if type(args['delnet']) == str:
                netname = args['delnet']
            ret = group.del_net_from_if(
                args['interface'], network_name=netname)
            return ret
        elif bool(args['rename']):
            return group.rename_interface(args['interface'], args['rename'])
        elif args['edit']:
            return group.set_if_params(
                args['interface'],
                _edit_script(group.get_if_params(args['interface']))
            )
        log.error('Action for interfaces should be specified.')
        return False

    if isinstance(args['torrent_if'], str):
        return group.set('torrent_if', args['torrent_if'])
    if bool(args['osimage']):
        return group.osimage(args['osimage'])
    if bool(args['domain']) or args['domain'] == '':
        return group.set_domain(args['domain'])
    if bool(args['bmcsetup']) or args['bmcsetup'] == '':
        return group.bmcsetup(args['bmcsetup'])

    return True


def group_clone(**args):
    source_group = luna.Group(name=args['name'])
    new_group = source_group.clone(args['to'])
    return new_group


def group_delete(**args):

    group = luna.Group(args['name'])
    return group.delete()


def group_rename(**args):
    grp = luna.Group(args['name'])
    return grp.rename(args['newname'])

#################### Node


def _get_node_interfaces(node):

    if_str = ''

    interfaces = node.list_ifs().keys()
    interfaces.sort()
    # get max len of the interfaces:
    padding = 0
    for interface in interfaces:
        if len(interface) > padding:
            padding = len(interface)

    for interface in interfaces:
        first_ip = True
        for ver in [4, 6]:
            ip = node.get_ip(interface, version=ver, quiet=True)
            if not ip:
                continue
            if first_ip:
                if_str += '{:<{}}{}\n'.format(
                    interface+":", padding+1, ip or '-')
                first_ip = False
            else:
                if_str += '{:<{}}{}\n'.format(" ", padding+1, ip or '-')
    if_str = if_str[:-1]

    return if_str


def _format_node_interfaces(interfaces):

    if_str = ''
    padding = 0
    for interface in interfaces:
        if len(interface) > padding:
            padding = len(interface)

    for interface in interfaces:
        first_ip = True
        for ver in [4, 6]:
            ip = interfaces[interface][ver]
            if not ip:
                continue
            if first_ip:
                if_str += '{:<{}}{}\n'.format(
                    interface+":", padding+1, ip or '-')
                first_ip = False
            else:
                if_str += '{:<{}}{}\n'.format(" ", padding+1, ip or '-')
    if_str = if_str[:-1]

    return if_str


def node_list(**args):
    header = ['Name', 'Group', 'MAC', 'IPs']
    content = []
    groups = luna.list('group')
    db = None
    for group_name in groups:
        group = luna.Group(group_name, mongo_db=db)
        if not db:
            db = group._mongo_db
        nodes = group.list_nodes()
        sorted_keys = nodes.keys()
        sorted_keys.sort()
        for node in sorted_keys:
            if_str = _format_node_interfaces(nodes[node]['interfaces'])
            mac = nodes[node]['mac']
            content.append([node, '[' + group_name + ']', mac, if_str])
    print_table(header, content)
    return True


def node_show(**args):
    name = args['name']
    raw = args['raw']
    script = args['script']
    for nodename in hostlist.expand_hostlist(name):

        node = luna.Node(name=nodename)
        if raw:
            print(node.nice_json)
            continue
        if args['comment']:
            print(node.get('comment'))
            continue
        if script:
            print(node.render_script(script))
            continue
        out_json = node.show()
        curent_node_name = out_json.pop('name')
        comment = out_json.pop('comment')
        status = node.get_status()
        if status:
            out_json['status'] = "%s - %s" % (status['status'], status['time'])
        if_str = _get_node_interfaces(node)
        out_json['interfaces'] = if_str.rstrip(', ')
        out_json['mac'] = node.get_mac()
        header = ['Parameter', 'Value']
        content = []
        content.append(['name', curent_node_name])
        for key in ['localboot', 'service', 'setupbmc']:
            if out_json[key]:
                out_json[key] = 'yes'
            else:
                out_json[key] = 'no'
        for key in sorted(out_json):
            content.append([key, out_json[key]])
        content.append(['comment', comment])
        print_table(header, content)
    return True


def node_add(**args):
    name = args['name']
    group = args['group']
    if name:
        for nodename in hostlist.expand_hostlist(name):
            node = luna.Node(name=nodename, group=group, create=True)
    else:
        node = luna.Node(name=name, group=group, create=True)
    return bool(node)


def node_change(**args):
    out = True
    new_comment = None

    for nodename in hostlist.expand_hostlist(args['name']):
        node = luna.Node(nodename)

        if args['comment']:
            if new_comment is None:
                old_comment = node.get('comment')
                new_comment = _edit_script(old_comment)
            out &= node.set('comment', new_comment)

        for attr in ['group', 'mac', 'switch']:
            if args[attr] is not None:
                res = getattr(node, "set_%s" % attr)(args[attr])
                out &= bool(res)

        for attr in ['localboot', 'setupbmc', 'service']:
            if args[attr] is not None:
                flag = True if args[attr] in ['y', 'yes'] else False
                res = node.set(attr, flag)
                out &= bool(res)

        if args['interface']:
            res = node.set_ip(args['interface'][0], ip=args['interface'][1])
            out &= bool(res)

        if args['bmcip']:
            res = node.set_ip(ip=args['bmcip'], bmc=True)
            out &= bool(res)

        if args['port']:
            res = node.set('port', args['port'])
            out &= bool(res)
    return out


def node_delete(**args):
    out = True
    name = args['name']
    for nodename in hostlist.expand_hostlist(name):
        node = luna.Node(nodename)
        res = node.delete()
        out &= bool(res)
    return out


def node_rename(**args):
    node = luna.Node(args['name'])
    return node.rename(args['newname'])

#################### Switch


def switch_list(**args):
    switches = luna.list('switch')
    header = ['Name', 'IP']
    content = []
    for elem in switches:
        switch = luna.Switch(elem)
        content.append([elem, switch.get('ip')])
    print_table(header, content)
    return True


def switch_show(**args):
    name = args['name']
    for switchname in hostlist.expand_hostlist(name):
        switch = luna.Switch(name=switchname)
        if args['raw']:
            print(switch.nice_json)
            continue
        if args['comment']:
            print(switch.get('comment'))
            continue
        out_json = switch.show()
        out_json['ip'] = switch.get('ip')
        header = ['Parameter', 'Value']
        content = []
        content.append(['name', out_json.pop('name')])
        comment = out_json.pop('comment')
        for key in sorted(out_json):
            content.append([key, out_json[key]])
        content.append(['comment', comment])
        print_table(header, content)
    return True


def switch_add(**args):
    name = args.pop('name')
    args['create'] = True
    out = True
    for switchname in hostlist.expand_hostlist(name):
        args['name'] = switchname
        switch = luna.Switch(**args)
        out &= bool(switch)
    return out


def switch_change(**args):
    out = True
    new_comment = None
    for switchname in hostlist.expand_hostlist(args.pop('name')):
        switch = luna.Switch(switchname)

        if args['comment']:
            if new_comment is None:
                old_comment = switch.get('comment')
                new_comment = _edit_script(old_comment)
            out &= switch.set('comment', new_comment)

        for key in args:
            if not args[key] or key == 'comment':
                continue
            ret = switch.set(key, args[key])
            out &= bool(ret)
    return out


def switch_delete(**args):
    out = True
    name = args['name']
    for switchname in hostlist.expand_hostlist(name):
        switch = luna.Switch(switchname)
        ret = switch.delete()
        out &= bool(ret)
    return out


def switch_rename(**args):
    sw = luna.Switch(args['name'])
    return sw.rename(args['newname'])

#################### Otherdev


def _list_otherdev_interfaces(dev):

    ips = []
    nets = dev.list_nets()
    nets.sort()
    padding = 0
    for n in nets:
        if len(n) > padding:
            padding = len(n)

    for net in dev.list_nets():
        tmp = "{:<{}}{}".format(
            "[" + net + "]:",
            padding + 3,
            dev.get_ip(net)
        )
        ips.append(tmp)

    return '\n'.join(ips)


def otherdev_list():
    devs = luna.list('otherdev')
    header = ['Name', 'IPs']
    content = []

    for elem in devs:
        dev = luna.OtherDev(elem)
        content.append([elem, _list_otherdev_interfaces(dev)])

    print_table(header, content)
    return True


def otherdev_show(**args):
    name = args['name']
    for devname in hostlist.expand_hostlist(name):
        dev = luna.OtherDev(name=devname)
        if args['raw']:
            print(dev.nice_json)
            continue
        if args['comment']:
            print(dev.get('comment'))
            continue
        out_json = dev.show()

        header = ['Parameter', 'Value']

        out_json['connected'] = _list_otherdev_interfaces(dev)

        content = []

        content.append(['name', out_json.pop('name')])

        comment = out_json.pop('comment')

        for key in sorted(out_json):
            content.append([key, out_json[key]])

        content.append(['comment', comment])

        print_table(header, content)
    return True


def otherdev_add(**args):
    name = args .pop('name')
    args['create'] = True
    out = True
    for otherdev in hostlist.expand_hostlist(name):
        args['name'] = otherdev
        dev = luna.OtherDev(**args)
        out &= bool(dev)
    return out


def otherdev_change(**args):
    out = True
    new_comment = None
    for devname in hostlist.expand_hostlist(args.pop('name')):
        dev = luna.OtherDev(devname)
        out &= bool(dev)

        if args['comment']:
            if new_comment is None:
                old_comment = dev.get('comment')
                new_comment = _edit_script(old_comment)
            out &= dev.set('comment', new_comment)

        if args['ip']:
            ret = dev.set_ip(network=args['network'], ip=args['ip'])
            out &= bool(ret)
    return out


def otherdev_delete(**args):
    name = args['name']
    out = True
    for devname in hostlist.expand_hostlist(name):
        dev = luna.OtherDev(devname)
        ret = dev.delete()
        out &= bool(ret)
    return out


def otherdev_rename(**args):
    otherdev = luna.OtherDev(args['name'])
    return otherdev.rename(args['newname'])

parser = ArgumentParser(prog='luna', description='Manage Luna Cluster')
parser.add_argument('--debug', '-d', action='store_true',
                    help='Show debug information')
subparsers = parser.add_subparsers(help='Items to operate on', dest='item')

cluster_p = subparsers.add_parser('cluster', help='Basic cluster operations')
cluster_a = cluster_p.add_subparsers(dest='action')

osimage_p = subparsers.add_parser('osimage', help='OsImage operations')
osimage_a = osimage_p.add_subparsers(dest='action')

bmcsetup_p = subparsers.add_parser('bmcsetup', help='BMCSetup operations')
bmcsetup_a = bmcsetup_p.add_subparsers(dest='action')

network_p = subparsers.add_parser('network', help='Node operations.')
network_a = network_p.add_subparsers(dest='action')

group_p = subparsers.add_parser('group', help='Group operations')
group_a = group_p.add_subparsers(dest='action')

node_p = subparsers.add_parser('node', help='Node operations')
node_a = node_p.add_subparsers(dest='action')

switch_p = subparsers.add_parser('switch', help='Switch operations')
switch_a = switch_p.add_subparsers(dest='action')

otherdev_p = subparsers.add_parser('otherdev', help='Other devices operations')
otherdev_a = otherdev_p.add_subparsers(dest='action')

#
# Cluster commands
#

# show
cmd = cluster_a.add_parser('show', help='Show options')
cmd.add_argument('--raw', '-R', action='store_true', help='JSON output')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')

# init
cmd = cluster_a.add_parser('init', help='Create Luna Cluster')
cmd.add_argument('--frontend_address', required=True,
                 help='Address of the controller\'s provisioning interface')
cmd.add_argument('--nodeprefix', default='node', help='Prefix for new nodes')
cmd.add_argument('--nodedigits', type=int, default=3, help='Zero-autopadding')
cmd.add_argument('--user', default='luna', help='Username to run services as')
cmd.add_argument('--path', default='/opt/luna', help='Path to store files')

# change
cmd = cluster_a.add_parser('change', help='Change cluster options')
cmd.add_argument('--nodeprefix', '-p', help='Prefix for new nodes')
cmd.add_argument('--nodedigits', '-d', type=int, help='Zero-autopadding')
cmd.add_argument('--path', help='Path to store files')
cmd.add_argument('--user', help='Username for running services')
cmd.add_argument('--frontend_address',
                 help='Address of the controller\'s provisioning interface')
cmd.add_argument('--frontend_port', type=int, help='Server address')
cmd.add_argument('--server_port', type=int, help='Server port')
cmd.add_argument('--tracker_interval', type=int,
                 help='Torrent tracker announce interval')
cmd.add_argument('--tracker_min_interval', type=int,
                 help='Torrent tracker announce min interval')
cmd.add_argument('--tracker_maxpeers', type=int,
                 help='Torrent tracker max allowed peers')
cmd.add_argument('--torrent_listen_port_min', type=int,
                 help='Torrent client listening port min')
cmd.add_argument('--torrent_listen_port_max', type=int,
                 help='Torrent client listening port max')
cmd.add_argument('--torrent_pidfile', help='Torrent pidfile')
cmd.add_argument('--lweb_num_proc', type=int,
                 help='Lweb number of processes. (0 for autodetection.)')
cmd.add_argument('--lweb_pidfile', type=int, help='Lweb pidfile')
cmd.add_argument('--cluster_ips', metavar='A.A.A.A,B.B.B.B',
                 help='IPs of the interfaces dedicated to provisioninig')
cmd.add_argument('--named_include_file', help='Include file for named.conf')
cmd.add_argument('--named_zone_dir', help='Dir where to store bind zone files')
#cmd.add_argument('--tracker_address', help='Torrent tracker address')
#cmd.add_argument('--tracker_port', type=int, help='Torrent tracker port')
#cmd.add_argument('--tracker_clean', action='store_true',
#                 help='Clean database from outdated records')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# sync
cmd = cluster_a.add_parser('sync', help='Synchronize cluster arcoss nodes')

# makedns
cmd = cluster_a.add_parser('makedns', help='Configure named')

# makedhcp
cmd = cluster_a.add_parser('makedhcp', help='Configure dhcpd')
cmd.add_argument('--native_dhcp_ha', action='store_true',
                 help='Create (native) config for high available DHCP.')
cmd.add_argument('--network', '-N', help='Network name')
cmd.add_argument('--start_ip', '-s',
                 help='First ip in dynamic range')
cmd.add_argument('--end_ip', '-e',
                 help='Last ip in dynamic range')
# delete
cmd = cluster_a.add_parser('delete', help='Delete Luna Cluster')
cmd.add_argument('--force', action='store_true', help='Drop backend database.')

# lmistmacs
cmd = cluster_a.add_parser('listmacs', help='List cached mac addresses.')

#
# OsImage commands
#

# list
cmd = osimage_a.add_parser('list', help='List OSImages')

# show
cmd = osimage_a.add_parser('show', help='Show OSImage')
cmd.add_argument('name', help='Name of the OsImage')
cmd_group = cmd.add_mutually_exclusive_group()
cmd_group.add_argument('--raw', '-R', action='store_true', help='JSON output')
cmd_group.add_argument('--path', '-p', action='store_true',
                       help='Show path to OsImage')
cmd_group.add_argument('--kernver', '-k', action='store_true',
                       help='Show kernel versions')
cmd_group.add_argument('--kernopts', '-o', action='store_true',
                       help='Show kernel options.')
cmd_group.add_argument('--grab_exclude_list', '-e', action='store_true',
                       help='Show exclude list for grabbing host')
cmd_group.add_argument('--grab_filesystems', '-f', action='store_true',
                       help='Show filesystems to grab from host')
cmd_group.add_argument('--comment', '-C', action='store_true',
                       help='Print comment')

# listkerns
#cmd = osimage_a.add_parser('listkerns',
#                           help='List installed kernels in OsImage')
#cmd.add_argument('name', help='Name of the OsImage')

# add
cmd = osimage_a.add_parser('add', help='Add osimage')
cmd.add_argument('--name', '-n', required=True, help='Name of the OsImage')
cmd.add_argument('--path', '-p', required=True, help='Path to OsImage')
cmd.add_argument(
    '--kernver', '-k',
    help=('Kernel version. Can be "ANY" keyword ' +
          '(will be used when parameter is ommited)')
)
cmd.add_argument('--kernopts', '-o', help='Kernel options')

# change
cmd = osimage_a.add_parser('change', help='Change OsImage')
cmd.add_argument('name', help='Name of the OsImage')
cmd_group = cmd.add_mutually_exclusive_group()
cmd_group.add_argument('--kernver', '-k', help='Kernel version')
cmd_group.add_argument('--kernopts', '-o', help='Kernel options')
cmd_group.add_argument('--dracutmodules', '-d', help='Dracut modules')
cmd_group.add_argument('--kernmodules', '-m', help='Kernel modules (drivers)')
cmd_group.add_argument('--path', '-p', help='Path to osimage (EXPERIMENTAL)')
cmd_group.add_argument('--grab_exclude_list', '-e', action='store_true',
                       help='Change exclude list for grabbing host')
cmd_group.add_argument('--grab_filesystems', '-f',
                       help='Comma-separated filesystems to grab from host')
cmd_group.add_argument('--comment', '-C', action='store_true',
                       help='Add comment')
# pack
cmd = osimage_a.add_parser('pack', help='Pack OsImage')
cmd.add_argument('name', help='Name of the OsImage')
cmd_group = cmd.add_mutually_exclusive_group(required=False)
cmd_group.add_argument('--image', '-i', action='store_true',
                       help='Pack image only')
cmd_group.add_argument('--boot', '-b', action='store_true',
                       help='Pack kernel and initrd only')
cmd.add_argument('--copy_boot', '-c', action='store_true',
                 help='Copy kernel and initrd from image, not to run dracut')

# grab
cmd = osimage_a.add_parser('grab', help='Grab host to OsImage')
cmd.add_argument('name', help='Name of the OsImage')
cmd.add_argument('--host', '-H', required=True,
                 help='Hostname of the source node')
cmd.add_argument('--dry_run', '-d', action='store_true',
                 help='Do not change osimage. Report only')
cmd.add_argument('--verbose', '-v', action='store_true',
                 help='Print rsync output')

# sync
cmd = osimage_a.add_parser('sync', help='Sync OsImage')
cmd.add_argument('name', help='Name of the OsImage')

# clone
cmd = osimage_a.add_parser('clone', help='Clone OsImage')
cmd.add_argument('name', help='Name of image to clone')
cmd.add_argument('--to', '-t', required=True, help='Name of the clone image')
cmd.add_argument('--path', '-p', required=True,
                 help='Path of the Osimage to create.')

# rename
cmd = osimage_a.add_parser('rename', help='Rename OsImage')
cmd.add_argument('name', help='Name of the OsImage')
cmd.add_argument('--newname', '--nn', required=True, help='New name')

# delete
cmd = osimage_a.add_parser('delete', help='Delete OsImage')
cmd.add_argument('name', help='Name of the OsImage')

#
# BMCSetup commands
#

# list
cmd = bmcsetup_a.add_parser('list', help='List BMCSetup instances.')

# show
cmd = bmcsetup_a.add_parser('show', help='Show BMCSetup instance.')
cmd.add_argument('name', help='Name of the BMCSetup')
cmd.add_argument('--raw', '-R', action='store_true', help='Raw JSON output')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')

# add
cmd = bmcsetup_a.add_parser('add', help='Add BMCSetup instance')
cmd.add_argument('--name', '-n', required=True, help='Name of the BMCSetup')
cmd.add_argument('--user', '-u', default='ladmin', help='User name')
cmd.add_argument('--password', '-p', default='ladmin', help='Password')
cmd.add_argument('--userid', '-I', default=3, type=int, help='UserID')
cmd.add_argument('--netchannel', '-N', default=1, type=int, help='Netchannel')
cmd.add_argument('--mgmtchannel', '-M', default=1, type=int,
                 help='Mgmtchannel')

# change
cmd = bmcsetup_a.add_parser('change', help='Change BMCSetup')
cmd.add_argument('name', help='Name of the BMCSetup')
cmd.add_argument('--user', '-u', help='User name')
cmd.add_argument('--password', '-p', help='Password')
cmd.add_argument('--userid', '-I', type=int, help='UserID')
cmd.add_argument('--netchannel', '-N', type=int, help='Netchannel')
cmd.add_argument('--mgmtchannel', '-M', type=int, help='Mgmtchannel')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# rename
cmd = bmcsetup_a.add_parser('rename', help='Rename BMCSetup instance')
cmd.add_argument('name', help='Name of the BMCSetup')
cmd.add_argument('--newname', '--nn', required=True,
                 help='New name of the BMCSetup')

# delete
cmd = bmcsetup_a.add_parser('delete', help='Delete osimage')
cmd.add_argument('name', help='Name of the BMCSetup')

#
# Network commands
#

# list
cmd = network_a.add_parser('list', help='List Networks')

# show
cmd = network_a.add_parser('show', help='Show Network')
cmd.add_argument('name', help='Name of the Network')
cmd.add_argument('--raw', '-R', action='store_true', help='Raw JSON output')
cmd.add_argument('--reservedips', '-r', action='store_true',
                 help='List reserved IPs')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')
# add
cmd = network_a.add_parser('add', help='Add Network')
cmd.add_argument('--name', '-n', required=True, help='Name of the Network')
cmd.add_argument('--network', '-N', metavar='N.N.N.N', required=True,
                 help='Network')
cmd.add_argument('--prefix', '-P', metavar='PP', required=True, type=int,
                 help='Prefix')
cmd.add_argument('--ns_hostname', help='Name server for zone file')
cmd.add_argument('--ns_ip', metavar='N.N.N.N',
                 help='Name server\'s IP for zone file')
# change
cmd = network_a.add_parser('change', help='Change Network')
cmd.add_argument('name', help='Name of the Network')
cmd.add_argument('--network', '-N', metavar='N.N.N.N', help='Network')
cmd.add_argument('--prefix', '-P', metavar='PP', type=int, help='Prefix')
cmd.add_argument('--reserve', '-R', metavar='X.X.X.X', help='Reserve IP')
cmd.add_argument('--release', metavar='X.X.X.X', help='Release IP')
cmd.add_argument('--ns_hostname', help='Name server for zone file')
cmd.add_argument('--ns_ip', metavar='N.N.N.N',
                 help='Name server\'s IP for zone file')
cmd.add_argument('--include', action='store_true',
                 help='Include data for zone file')
cmd.add_argument('--rev_include', action='store_true',
                 help='Include data for reverse zone file')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')
# rename
cmd = network_a.add_parser('rename', help='Rename Network')
cmd.add_argument('name', help='Name of the Network')
cmd.add_argument('--newname', '--nn', required=True,
                 help='New name of the Network')
# delete
cmd = network_a.add_parser('delete', help='Delete Network')
cmd.add_argument('name', help='Name of the Network')

#
# Group commands
#

# list
cmd = group_a.add_parser('list', help='List Groups')

# show
cmd = group_a.add_parser('show', help='Show Group')
cmd.add_argument('name', help='Name of the Group')
cmd_group = cmd.add_mutually_exclusive_group()
cmd_group.add_argument('--raw', '-R', action='store_true', help='JSON output')
cmd_group.add_argument('--osimage', '-o', action='store_true',
                       help='Show osimage assigned to Group.')
cmd_group.add_argument('--prescript', '--pre', action='store_true',
                       help='Show prescript')
cmd_group.add_argument('--postscript', '--post', action='store_true',
                       help='Show postscript.')
cmd_group.add_argument('--partscript', '--part', action='store_true',
                       help='Show partition script.')
cmd_group.add_argument('--bmcsetup', '-b', action='store_true',
                       help='BMCSetup assigned to Group.')
cmd_group.add_argument('--interface', '-i', help='Interface')
cmd_group.add_argument('--comment', '-C', action='store_true',
                       help='Print comment')

# add
cmd = group_a.add_parser('add', help='Add Group')
cmd.add_argument('--name', '-n', required=True, help='Name of the Group')
cmd.add_argument('--osimage', '-o', required=True,
                 help='Osimage assigned to Group')
cmd.add_argument('--bmcsetup', '-b', help='BMCSetup assigned to Group')
cmd.add_argument('--bmcnetwork', '-bn', help='Network for BMC interface')
cmd.add_argument('--network', '-N', required=True,
                 help='Network for boot interface')

# change
cmd = group_a.add_parser('change', help='Change Group')
cmd.add_argument('name', help='Name of the Group')
cmd.add_argument('--osimage', '-o', help='Osimage assigned to Group')
cmd.add_argument('--domain', '-d', help='Domain')
cmd.add_argument('--prescript', '--pre', action='store_true',
                 help='Set prescript')
cmd.add_argument('--postscript', '--post', action='store_true',
                 help='Set postscript.')
cmd.add_argument(
    '--partscript', '--part',
    action='store_true',
    help='Set partition script. Localdisk should be mounted under /sysimage'
)
cmd.add_argument('--bmcsetup', '-b', help='BMCSetup assigned to Group')
cmd.add_argument('--torrent_if', '--ti', help='High-speed interface')
cmd.add_argument('--interface', '-i', help='Interface')
cmd.add_argument('--add', '-A', action='store_true',
                 help='Add interface')
cmd.add_argument('--delete', '-D', action='store_true',
                 help='Delete interface')
cmd.add_argument('--setnet', '--sn', metavar='NETWORK',
                 help='Set Network for interface or for BMC')
cmd.add_argument('--delnet', '--dn', action='store',
                 nargs='?', default=False, const=True,
                 help='Delete Network for interface or for BMC')
cmd.add_argument('--edit', '-e', action='store_true',
                 help='Edit interface parameters or edit scripts')
cmd.add_argument('--rename', '--nn', metavar='NEW_NAME',
                 help='Rename interface')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# clone
cmd = group_a.add_parser('clone', help='Clone Group.')
cmd.add_argument('name', help='Name of the Group')
cmd.add_argument('--to', '-t', required=True, help='Name of the clone group')

# rename
cmd = group_a.add_parser('rename', help='Rename Group.')
cmd.add_argument('name', help='Name of the Group')
cmd.add_argument('--newname', '--nn', required=True, help='New name')

# delete
cmd = group_a.add_parser('delete', help='Delete Group')
cmd.add_argument('name', help='Name of the Group')

#
# Node commands
#

# list
cmd = node_a.add_parser('list', help='List Nodes')

# show
cmd = node_a.add_parser('show', help='Show Node')
cmd.add_argument('name', help='Name of the Node')
cmd.add_argument('--raw', '-R', action='store_true', help='Raw JSON output')
cmd.add_argument('--script', '-s', choices=['boot', 'install'],
                 help='Show script for node')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')

# add
cmd = node_a.add_parser('add', help='Add Node')
cmd.add_argument('--name', '-n', help='Name of the Node')
cmd.add_argument('--group', '-g', required=True, help='Group')

# change
cmd = node_a.add_parser('change', help='Change Node')
cmd.add_argument('name', help='Name of the Node')
cmd_group = cmd.add_mutually_exclusive_group(required=False)
cmd_group.add_argument('--group', '-g', help='Group')
cmd_group.add_argument('--interface', '-i', nargs=2, metavar=('IF', 'X.X.X.X'),
                       help='Assign ip address to interface')
cmd_group.add_argument('--bmcip', '-b', metavar='X.X.X.X',
                       help='Assign ip address to BMC interface')
cmd.add_argument('--mac', metavar='XX:XX:XX:XX:XX',
                 help='Mac address. Specify empty string to erase')
cmd.add_argument('--switch', '-s', help='Switch')
cmd.add_argument('--port', '-p', help='Switch port')
cmd.add_argument('--localboot', '-l', choices=['y', 'yes', 'n', 'no'],
                 help='Boot from local HDD')
cmd.add_argument('--setupbmc', '--sb', choices=['y', 'yes', 'n', 'no'],
                 help='Whether to setup BMC on install')
cmd.add_argument('--service', '--sv', choices=['y', 'yes', 'n', 'no'],
                 help='Enter to service mode instead of install')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# rename
cmd = node_a.add_parser('rename', help='Rename Node')
cmd.add_argument('name', help='Name of the Node')
cmd.add_argument('--newname', '--nn', required=True, help='New name')

# delete
cmd = node_a.add_parser('delete', help='Delete Node')
cmd.add_argument('name', help='Name of the Node')

#
# Switch commands
#

# list
cmd = switch_a.add_parser('list', help='List Switches')

# show
cmd = switch_a.add_parser('show', help='Show Switch')
cmd.add_argument('name', help='Name of the Switch')
cmd.add_argument('--raw', '-R', action='store_true', help='Raw JSON output')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')

# add
cmd = switch_a.add_parser('add', help='Add Switch')
cmd.add_argument('--name', '-n', required=True, help='Name of the Switch')
cmd.add_argument('--network', '-N', required=True,
                 help='Network Switch belongs to')
cmd.add_argument('--ip', '-i', required=True, help='IP of the Switch')
cmd.add_argument('--read', '-r', default='public', help='Read community')
cmd.add_argument('--rw', '-w', default='private', help='Write community')
cmd.add_argument('--oid', '-o', default='.1.3.6.1.2.1.17.7.1.2.2.1.2',
                 help='OID of the Switch')

# change
cmd = switch_a.add_parser('change', help='Change Switch')
cmd.add_argument('name', help='Name of the Switch')
cmd.add_argument('--network', '-N', help='Network Switch belongs to')
cmd.add_argument('--ip', '-i', help='IP of the Switch')
cmd.add_argument('--read', '-r', help='Read community')
cmd.add_argument('--rw', '-w', help='Write community')
cmd.add_argument('--oid', '-o', help='OID of the Switch')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# rename
cmd = switch_a.add_parser('rename', help='Rename Switch')
cmd.add_argument('name', help='Name of the Switch')
cmd.add_argument('--newname', '--nn', required=True, help='New name')

# delete
cmd = switch_a.add_parser('delete', help='Delete Switch')
cmd.add_argument('name', help='Name of the Switch')

#
# Otherdev commands
#

# list
cmd = otherdev_a.add_parser('list', help='List other devices')

# show
cmd = otherdev_a.add_parser('show', help='Show device')
cmd.add_argument('name', help='Name of the device')
cmd.add_argument('--raw', '-R', action='store_true', help='Raw JSON output')
cmd.add_argument('--comment', '-C', action='store_true', help='Print comment')

# add
cmd = otherdev_a.add_parser('add', help='Add device')
cmd.add_argument('--name', '-n', required=True, help='Name of the device')
cmd.add_argument('--network', '-N', required=True,
                 help='Network device belongs to')
cmd.add_argument('--ip', '-i', help='IP of the device')

# change
cmd = otherdev_a.add_parser('change', help='Change device')
cmd.add_argument('name', help='Name of the device')
cmd.add_argument('--network', '-N', help='Network device belongs to')
cmd.add_argument('--ip', '-i',
                 help='IP of the device. Specify empty string to delete')
cmd.add_argument('--comment', '-C', action='store_true', help='Add comment')

# rename
cmd = otherdev_a.add_parser('rename', help='Rename device')
cmd.add_argument('name', help='Name of the device')
cmd.add_argument('--newname', '--nn', required=True, help='New name')

# delete
cmd = otherdev_a.add_parser('delete', help='Delete device')
cmd.add_argument('name', help='Name of the device')


if __name__ == '__main__':
        args = vars(parser.parse_args())
        debug = args.pop('debug')

        if debug:
            log.setLevel(logging.DEBUG)

        try:

            if args['action'] in ['add', 'change', 'rename', 'delete']:
                check_active_node()

            call_fun = globals()['%s_%s' % (args['item'], args['action'])]
            args.pop('item')
            args.pop('action')

            res = call_fun(**args)
            if not res:
                exit(1)
            exit(0)

        except RuntimeError as e:

            if debug:
                traceback.print_exc(file=sys.stderr)

            exit(255)
        except:
            raise
